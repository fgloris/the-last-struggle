# 编译原理速通
速通这玩意真的有可能吗?

但我们是开卷考试, 我可以把它当小抄! 哈哈哈!

里面所有的"书"均指清华教材编译原理第3版(紫书)

## 默认你懂符号串运算

## 文法的定义
### G={Vn, Vt, P, S} (常表示为G[S])
- Vn是非终结符集合
- Vt是终结符集合
- 下面用V表示Vn⋃Vt
- P是规则集合
- S是开始符(不是集合), 属于Vn, 至少在一个P的规则中作为左部出现
### 相关定义
- **句型**是由G从S推导出来的符号串
- 所有符号都是终结符的句型是**句子**
- **语言**L(G)是所有G能推导出来的所有句子的集合

## 文法的分类 (语言从复杂到简单, 限制从少到多)
### 0型文法
- 对应图灵机
- 只要符合文法的基本定义就是0型文法, 即P中每一个规则 α -> β中, α至少包括一个非终结符

### 1型文法 (上下文有关文法)
- 对应于线性有界自动机(受到一点点限制的图灵机)
- 定义: P中每一个规则 α -> β 有 |α| <= |β| (特例:|α|=1, β=ε 算符合)
- 每一个产生式都不会使长度变短

### 2型文法 (上下文无关文法)
- 对应于下推自动机(DFA加一个无限大的栈)
- 定义: P中每一个规则都为 A -> β, A是非终结符, β∈V*
- 适用于LL(1)分析

### LR(k)文法
- 适用于LR分析
- 2型文法经过更强的限制得到:

### LL(k)文法
- 适用于确定的自顶向下分析
- 2型文法经过更强的限制得到: 它的 SELECT 集合满足 SELECT(A->α) ⋂ SELECT(A->β) = ∅
- L:从左向右扫描句型; L:使用最左推导; k:只要向右看k个符号就可以决定使用哪个产生式推导

### 3型文法 (正则文法/正规文法)
- 对应于有限状态自动机, 即DFA, 也同样对应NFA
- 正则表达式用来表示此文法
- 分为左线性文法和右线性文法
- 定义: P中每一个规则都为 A ->a | aB (左线性文法) 或 A ->a | Ba (右线性文法), A和B都是非终结符, a∈Vt*

### 对分类的理解
- 从0 -> 1 (限制α长度小于β) -> 2 (限制α长度为1) -> 3 (限制β), 限制逐渐增强
- 2 -> LL(k) -> LL(k-1) -> ... -> LL(1), 限制逐渐增强
- LR(k) 比 LL(k) 限制少
- "上下文无关"比"上下文有关"约束更为强烈, 上下文有关推出的语言更复杂, 比如a b(c);是一个变量定义还是一个函数声明取决于符号c的含义, 即先前c的定义, 这个语句的解析上下文无关比更为复杂
- 如果说一个语言不是上下文无关的, 它大概率是1型文法
- C/C++ 是1型文法 (也许是, 但肯定不是2型或3型)
- Markdown 不是2型或3型文法, 其中*的含义取决于上下文
- pl0语言是2型文法, 好像不是正则文法

## 2型文法的语法树
- 由于P中每一个规则都为 A -> β, A是单个非终结符, 故可以对一个句子构建语法树
- 语法树用来表示2型文法的推导过程
- 如果每次推导都从最右边开始, 称为最右推导(规范推导), 得到右句型(规范句型)
- 若可以构造多个最左/最右推导过程, 称此文法是二义的
- 若一个语言的所有文法都是二义的, 称此语言先天二义
- 构造语法树有两种方法, 自顶向下和自底向上
- 对于每一棵子树, 称:
    所有的叶子节点构成的符号串 是 该句型相对于根节点的**短语**, 若子树高度为2(直接推出), 则为相对于该直接推出规则的**直接短语**
- 右句型的直接短语称为**句柄**

    举一个例子:

    G[S]:
    - S -> T|S+T
    - T -> F|T*F
    - F -> (S)|i

    句型: i*i+i

    该句型的语法树: (用Typora看更香)
    ```mermaid
        graph TD;
        s2["S"]
        f2["F"]
        f3["F"]
        t2["T"]
        t3["T"]
        i2["i"]
        i3["i"]
        S-->s2;
        S-->+;
        S-->T;
        T-->F;
        F-->i;
        s2-->t2
        t2-->t3
        t2-->*
        t2-->f2
        t3-->f3
        f2-->i2
        f3-->i3
    

- 此时句型i*i+i的短语有:
    - i*i+i (相对于S)
    - i*i (相对于T) (相对于S)
    - i (相对于F) (相对于T) (直接短语, 相对于规则F->i)

## 词法分析
- 把字符流变成单词序列
- 需要借助语言的词法规则, 通常是正规文法
- 通过正规语法构造NFA, 然后转为DFA, 再进行DFA的化简 (书p47)

## 确定的自顶向下语法分析 (LL(1)文法)

- 从S开始, 不断地选择表达式拓展成目标的样子, 关键在**避免错误的选择**
- 我们需要构造SELECT集以进行正确的选择
- SELECT集由FIRST集和FOLLOW集构造, 结合二者信息共同判断是否选择该规则
    - FIRST(α) = {t| α=\*>tβ, t∈Vt, α, β∈V*}

        (相对于句型)句型推出的所有短语中的开头终结符

        若 α∈Vt, 则FIRST(α) = {α} (显然如此)

    - FOLLOW(A) = {t| S=\*>...At..., t∈Vt, β∈V*, A∈Vn}

        (相对于非终结符)非终结符后面紧跟着的所有终结符
    - SELECT(A->α) = (FIRST(α)-{ε} ⋃ FOLLOW(A))
    - LL(1)的分析法:
        - 递归下降子程序法
        - 表驱动 (等下介绍)

- 对于部分非LL(1)的2型文法, 可以将其转换为LL(1), 使其适用确定的自顶向下语法分析
    - 提取左公因子
    
        例子:
        G[S]:
        - S -> aSb
        - S -> aS

        先提取a:
        - S -> aS(b|ε)

        再把括号转换为非终结符:
        - S -> aSA
        - A -> b
        - A -> ε

    - 消除左递归 (变成右递归)


## 不确定的自顶向下语法分析 (2型非LL(1)文法)

- 从S开始, 不断地选择表达式拓展成目标的样子, 允许错误的选择, 需要**回溯**
- 不常用也不考


## 自底向上优先分析 (2型文法)

- 从目标句型开始, 不断地选择表达式进行归约, 最后只剩S, 关键也在**避免错误的选择**

## 表驱动LL(1)分析程序
- 句子括号用#表示, 即用#...#括起整个句子
- 见书p94
## 