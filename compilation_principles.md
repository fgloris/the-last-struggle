# 编译原理速通
速通这玩意真的有可能吗?

但我们是开卷考试, 我可以把它当小抄! 哈哈哈!

里面所有的"书"均指清华教材编译原理第3版(紫书)

## 默认你懂符号串运算

## 文法的定义
### G={Vn, Vt, P, S} (常表示为G[S])
- Vn是非终结符集合
- Vt是终结符集合
- 下面用V表示Vn⋃Vt
- P是规则集合
- S是开始符(不是集合), 属于Vn, 至少在一个P的规则中作为左部出现
### 相关定义
- **句型**是由G从S推导出来的符号串
- 所有符号都是终结符的句型是**句子**
- **语言**L(G)是所有G能推导出来的所有句子的集合

## 文法的分类 (语言从复杂到简单, 限制从少到多)
### 0型文法
- 对应图灵机
- 只要符合文法的基本定义就是0型文法, 即P中每一个规则 α -> β中, α至少包括一个非终结符

### 1型文法 (上下文有关文法)
- 对应于线性有界自动机(受到一点点限制的图灵机)
- 定义: P中每一个规则 α -> β 有 |α| <= |β| (特例:|α|=1, β=ε 算符合)
- 每一个产生式都不会使长度变短

### 2型文法 (上下文无关文法)
- 对应于下推自动机(DFA加一个无限大的栈)
- 定义: P中每一个规则都为 A -> β, A是非终结符, β∈V*

### LR(k)文法
- 适用于LR分析
- 2型文法经过更强的限制得到:
- 考试中k=0或1

### LL(k)文法
- 考试中k=1
- k=1时,适用于确定的自顶向下分析
- 2型文法经过更强的限制得到: 它的 SELECT 集合满足 SELECT(A->α) ⋂ SELECT(A->β) = ∅
- L:从左向右扫描句型; L:使用最左推导; k:只要向右看k个符号就可以决定使用哪个产生式推导

### 3型文法 (正则文法/正规文法)
- 对应于有限状态自动机, 即DFA, 也同样对应NFA
- 正则表达式用来表示此文法
- 分为左线性文法和右线性文法
- 定义: P中每一个规则都为 A ->a | aB (左线性文法) 或 A ->a | Ba (右线性文法), A和B都是非终结符, a∈Vt*

### 对分类的理解
- 从0 -> 1 (限制α长度小于β) -> 2 (限制α长度为1) -> 3 (限制β), 限制逐渐增强
- 2 -> LL(k) -> LL(k-1) -> ... -> LL(1), 限制逐渐增强
- LR(k) 比 LL(k) 限制少
- "上下文无关"比"上下文有关"约束更为强烈, 上下文有关推出的语言更复杂, 比如a b(c);是一个变量定义还是一个函数声明取决于符号c的含义, 即先前c的定义, 这个语句的解析上下文无关比更为复杂
- 如果说一个语言不是上下文无关的, 它大概率是1型文法
- C/C++ 是1型文法 (也许是, 但肯定不是2型或3型)
- Markdown 不是2型或3型文法, 其中*的含义取决于上下文
- pl0语言是2型文法, 好像不是正则文法

## 2型文法的语法树
- 由于P中每一个规则都为 A -> β, A是单个非终结符, 故可以对一个句子构建语法树
- 语法树用来表示2型文法的推导过程
- 如果每次推导都从最右边开始, 称为最右推导(规范推导), 得到右句型(规范句型)
- 若可以构造多个最左/最右推导过程, 称此文法是二义的
- 若一个语言的所有文法都是二义的, 称此语言先天二义
- 构造语法树有两种方法, 自顶向下和自底向上
- 对于每一棵子树, 称:
    所有的叶子节点构成的符号串 是 该句型相对于根节点的**短语**, 若子树高度为2(直接推出), 则为相对于该直接推出规则的**直接短语**
- 右句型的直接短语称为**句柄**

    举一个例子:

    G[S]:
    - S -> T|S+T
    - T -> F|T*F
    - F -> (S)|i

    句型: i*i+i

    该句型的语法树: (用Typora看更香)
    ```mermaid
        graph TD;
        s2["S"]
        f2["F"]
        f3["F"]
        t2["T"]
        t3["T"]
        i2["i"]
        i3["i"]
        S-->s2;
        S-->+;
        S-->T;
        T-->F;
        F-->i;
        s2-->t2
        t2-->t3
        t2-->*
        t2-->f2
        t3-->f3
        f2-->i2
        f3-->i3
    

- 此时句型i*i+i的短语有:
    - i*i+i (相对于S)
    - i*i (相对于T) (相对于S)
    - i (相对于F) (相对于T) (直接短语, 相对于规则F->i)

## 词法分析
- 把字符流变成单词序列
- 需要借助语言的词法规则, 通常是正规文法
- 通过正规语法构造NFA, 然后转为DFA, 再进行DFA的化简 (书p47)

## 确定的自顶向下语法分析 (LL(1)文法)

- 从S开始, 不断地选择表达式拓展成目标的样子, 关键在**避免错误的选择**
- 我们需要构造SELECT集以进行正确的选择
- SELECT集由FIRST集和FOLLOW集构造, 结合二者信息共同判断是否选择该规则
    - FIRST(α) = {t| α=\*>tβ, t∈Vt, α, β∈V*}

        (相对于句型) 句型推出的所有结果中的开头终结符

        若 α∈Vt, 则FIRST(α) = {α} (显然如此)

    - FOLLOW(A) = {t| S=\*>...At..., t∈Vt, β∈V*, A∈Vn}

        (相对于非终结符) 非终结符后面紧跟着的所有终结符
    - SELECT(A->α) = (FIRST(α)-{ε} ⋃ FOLLOW(A))
- LL(1)的分析法:
    - 递归下降子程序法 (如果依靠程序员的本能写parser大概率会得到这个东西)
    - 表驱动 (书p93)

        预测分析表

- 那么怎么判断给定2型文法是不是LL(1)的呢?
    - 先求出能推出ε的非终结符, 如果某个非终结符A能推出ε, 等下给他的FIRST集加上ε (相当于单独考虑ε)
    - 求所有文法文法符号的FIRST集: 这里有一些技巧减少重复计算
        - 先不考虑FIRST包含ε
        - 终结符的FIRST集只有它自己
        - 按定义求一些简单的FIRST集
        - 书本: 若X, Y<sub>1</sub>, Y<sub>2</sub>...Y<sub>n</sub>∈Vn,
        X -> Y<sub>1</sub>, Y<sub>2</sub>...Y<sub>n</sub>, 
        且Y<sub>1</sub>, Y<sub>2</sub>...Y<sub>i-1</sub> =\*> ε,
        则Y<sub>1</sub>, Y<sub>2</sub>...Y<sub>i</sub>的FIRST集合包含在FIRST(X)中 (所有FIRST集不含ε) (0<=i<=n)
        
            意思是, **若有X=\*>Y, 则FIRST(Y)⊆FIRST(X)** (所有FIRST集不含ε)
        - 最后给能推出ε的非终结符FIRST集加上ε
    - 求所有规则中右边符号串的FIRST
        - 若以非终结符号开头, 则其FIRST集就是该终结符
        - 其他的参照上面
    - 计算所有非终结符的FOLLOW集
        - FOLLOW集中没有ε
        - \#∈FOLLOW(S), S为开始符
        - **若有A -> ...Bβ, 则有FIRST(β)-{ε}⊆FOLLOW(B)**
        - **若有A =\*> ...B, 则有FOLLOW(A)⊆FOLLOW(B)**


- 对于大部分非LL(1)的2型文法, 可以将其**转换为LL(1)**, 使其适用确定的自顶向下语法分析
    - 提取左公因子
    
        例子:
        G[S]:
        - S -> aSb
        - S -> aS

        先提取a:
        - S -> aS(b|ε)

        再把括号转换为非终结符:
        - S -> aSA
        - A -> b
        - A -> ε

    - 消除左递归 (变成右递归)
    
        什么是左递归?
        - 直接左递归: 
            - S -> Sa
            - S -> b
        - 间接左递归: 
            - A -> Ba
            - B -> Ab
            - B -> ε

        怎么消除左递归?
        
        - 直接左递归: 改写上例变成右递归: 
            - S -> bS'
            - S' -> aS'|ε

        - 间接左递归: 通过代入把间接左递归文法改写为直接左递归文法, 再消除

            此例中把第一个规则代入第二个规则, 得到:
            - B -> Bab
            - B -> ε
        


## 不确定的自顶向下语法分析 (2型非LL(1)文法)

- 从S开始, 不断地选择表达式拓展成目标的样子, 允许错误的选择, 需要**回溯**
- 不常用也不考

## 自底向上优先分析 (2型文法)

- 从目标句型开始, 不断地选择表达式进行归约, 最后只剩S, 关键也在**避免错误的选择**

## LR分析

## 表驱动LL(1)分析程序
- 句子括号用#表示, 即用#...#括起整个句子
- 见书p94
## 